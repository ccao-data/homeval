---
title: "Pin Comparison Doc"
params:
  run_id: "2024-03-17-stupefied-maya"
  pin1: "20143120370000"
  pin_1_card_num: 4
  pin2: "11192020200000"
  pin_2_card_num:
execute:
  echo: false
  warning: false
  cache: true
format:
  html:
    embed-resources: true
    grid:
      body-width: 1000px
    fig-format: svg

---

```{r load_libraries}
#| cache: true

library(arrow)
library(ccao)
library(dplyr)
library(DT)
library(ggalt)
library(glue)
library(ggplot2)
library(ggtext)
library(leaflet)
library(noctua)
library(purrr)
library(RColorBrewer)
library(scales)
library(sf)
library(stringr)
library(tidyr)

noctua_options(cache_size = 10, unload = FALSE)

conn <- dbConnect(noctua::athena(),
  rstudio_conn_tab = FALSE
)
```


```{r compute_motivating_example}
run_id <- params$run_id

year <- run_id %>%
  substr(1, 4)

na_if_null <- function(x) {
  if (is.null(x)) NA else x
}

pin_labels <- data.frame(
  meta_pin = c(params$pin1, params$pin2),
  meta_pin_label = c("Pin 1", "Pin 2"),
  primary_card = c(na_if_null(params$pin_1_card_num), na_if_null(params$pin_2_card_num))
)

# Query the predictor list and the hash of the assessment set for the example
# model run
metadata <- dbGetQuery(
  conn,
  # This query should only ever return one row, but limit the results to 1
  # just to be defensive
  glue(
    "
    select
      dvc_md5_assessment_data,
      model_predictor_all_name
    from model.metadata
    where run_id = '{run_id}'
    limit 1
    "
  )
)

model_predictor_all_name <- metadata$model_predictor_all_name %>% unlist()
model_predictor_all_name <- trimws(strsplit(gsub("^\\[|\\]$", "", model_predictor_all_name), ",")[[1]])

char_df <- open_dataset(
  paste0(
    "s3://ccao-data-dvc-us-east-1/files/md5/",
    substr(metadata$dvc_md5_assessment_data, 1, 2), "/",
    substr(metadata$dvc_md5_assessment_data, 3, 32)
  )
) %>%
  filter(meta_pin %in% pin_labels$meta_pin) %>%
  collect() %>%
  select(
    meta_pin,
    all_of(model_predictor_all_name),
    meta_card_num
  )

pin_labels <- pin_labels %>%
  left_join(
    char_df %>%
      group_by(meta_pin) %>%
      summarise(
        total_cards = n_distinct(meta_card_num)
      ),
    by = "meta_pin"
  )

# Check that for rows where total_cards <= 3, primary_card is NA
if (nrow(pin_labels %>% filter(total_cards <= 3 & !is.na(primary_card))) > 0) {
  stop("Error: For rows with total_cards <= 3, primary_card should be NA.")
}

# Check that for rows where total_cards >= 4, primary_card is not NA
if (nrow(pin_labels %>% filter(total_cards >= 4 & is.na(primary_card))) > 0) {
  stop("Error: For rows with total_cards >= 4, primary_card should have a value.")
}

char_df <- char_df %>%
  left_join(pin_labels %>% select(meta_pin, primary_card, total_cards), by = "meta_pin") %>%
  group_by(meta_pin) %>%
  mutate(
    # Determine if this row is the target row within groups of 2 or 3 observations.
    is_target = total_cards %in% c(2, 3) & char_bldg_sf == max(char_bldg_sf, na.rm = TRUE),
    # Replace primary_card with meta_card_num for the target row; otherwise, keep the existing value.
    primary_card = if_else(is_target, meta_card_num, as.character(primary_card)),
    # For groups with 2 or 3 cards, replace char_bldg_sf with the group sum on the target row.
    char_bldg_sf = if_else(is_target, sum(char_bldg_sf, na.rm = TRUE), char_bldg_sf)
  ) %>%
  ungroup() %>%
  # Keep only the target row for groups where we did the replacement.
  filter(primary_card == meta_card_num) %>%
  select(-c("meta_card_num", "total_cards", "is_target"))


pin_labels <- pin_labels %>%
  left_join(
    char_df %>%
      select(meta_pin, primary_card) %>%
      distinct(),
    by = "meta_pin",
    suffix = c("", ".computed")
  ) %>%
  mutate(
    primary_card = as.character(primary_card),
    primary_card = coalesce(primary_card, primary_card.computed)
  ) %>%
  select(-primary_card.computed)

value_df <- dbGetQuery(
  conn,
  glue_sql(
    "
    select
      card.meta_pin,
      card.meta_card_num,
      card.pred_card_initial_fmv,
      pin.pred_pin_final_fmv_round
    from model.assessment_card as card
    left join model.assessment_pin as pin
      on card.meta_pin = pin.meta_pin
      and card.meta_year = pin.meta_year
      and card.run_id = pin.run_id
    where card.run_id = {run_id}
    and card.meta_pin in ({pin_labels$meta_pin*})
    ",
    .con = conn
  )
)

value_df <- value_df %>%
  left_join(pin_labels, by = c("meta_pin"))

shap_df <- dbGetQuery(
  conn,
  glue_sql(
    "
    select
      meta_pin,
      meta_card_num,
      {`model_predictor_all_name`*}
    from model.shap
    where run_id = {run_id}
      and meta_pin in ({pin_labels$meta_pin*})
    ",
    .con = conn
  )
)


shap_df <- shap_df %>%
  left_join(pin_labels, by = c("meta_pin")) %>%
  filter(primary_card == meta_card_num) %>%
  select(-c("meta_pin_label", "total_cards", "primary_card", "meta_card_num"))


address <- dbGetQuery(
  conn,
  glue_sql(
    "
    select
      pin,
      year,
      prop_address_full,
      prop_address_city_name,
      prop_address_state,
      prop_address_zipcode_1
    from default.vw_pin_address
    where pin in ({pin_labels$meta_pin*})
    and year = {year}
    ",
    .con = conn
  )
)

address <- address %>%
  mutate(full_address = paste(prop_address_full,
    prop_address_city_name,
    prop_address_state,
    prop_address_zipcode_1,
    sep = ", "
  )) %>%
  select(pin, full_address)

sales <- dbGetQuery(
  conn,
  glue_sql(
    "
    select
      pin,
      year,
      sale_date,
      doc_no,
      sale_price,
      sv_is_outlier
    from default.vw_pin_sale
    where pin in ({pin_labels$meta_pin*})
    ",
    .con = conn
  )
)

comps <- dbGetQuery(
  conn,
  glue_sql(
    "
    select
      comp.pin,
      comp.comp_pin_1,
      comp.comp_pin_2,
      comp.comp_pin_3,
      comp.comp_pin_4,
      comp.comp_pin_5,
      comp.comp_pin_6,
      comp.comp_pin_7,
      comp.comp_pin_8,
      comp.comp_pin_9,
      comp.comp_pin_10,
      comp.comp_pin_11,
      comp.comp_pin_12,
      comp.comp_pin_13,
      comp.comp_pin_14,
      comp.comp_pin_15,
      comp.comp_pin_16,
      comp.comp_pin_17,
      comp.comp_pin_18,
      comp.comp_pin_19,
      comp.comp_pin_20,
      comp.comp_score_1,
      comp.comp_score_2,
      comp.comp_score_3,
      comp.comp_score_4,
      comp.comp_score_5,
      comp.comp_score_6,
      comp.comp_score_7,
      comp.comp_score_8,
      comp.comp_score_9,
      comp.comp_score_10,
      comp.comp_score_11,
      comp.comp_score_12,
      comp.comp_score_13,
      comp.comp_score_14,
      comp.comp_score_15,
      comp.comp_score_16,
      comp.comp_score_17,
      comp.comp_score_18,
      comp.comp_score_19,
      comp.comp_score_20,
      comp.card
    from model.comp as comp
    where comp.run_id = {run_id}
    and comp.pin in ({pin_labels$meta_pin*})
    ",
    .con = conn
  )
)

comps <- comps %>%
  left_join(pin_labels, by = c("pin" = "meta_pin")) %>%
  filter(primary_card == card) %>%
  select(-c("meta_pin_label", "primary_card"))
```

### Map of Parcels

```{r}
char_df %>%
  left_join(address, by = c("meta_pin" = "pin")) %>%
  leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addCircleMarkers(
    lat = ~loc_latitude,
    lng = ~loc_longitude,
    popup = ~ ifelse(
      meta_pin == params$pin1,
      paste0(
        "Address: ", full_address, "<br>",
        "PIN: ",
        "<a href='https://www.cookcountyassessor.com/pin/", params$pin1,
        "' target='_blank'>", params$pin1, "</a>"
      ),
      ifelse(
        meta_pin == params$pin2,
        paste0(
          "Address: ", full_address, "<br>",
          "PIN: ",
          "<a href='", params$website2, params$pin2,
          "' target='_blank'>", params$pin2, "</a>"
        ),
        paste0("Address: ", address)
      )
    ),
    color = ~ ifelse(
      meta_pin == params$pin1, "red",
      ifelse(meta_pin == params$pin2, "blue", "green")
    ),
    radius = 5
  )
```

### Feature differences between the two parcels

Note that for parcels with 2 or 3 cards, the building square footage is summed. For the rest of the features, they are pulled from the largest of the two parcels. This coincides with our modeling techniques. For parcels with 4 or more pins, we pull the features from the target card identified in the params.

```{r, out.width="90%"}
char_df_fmt <- char_df %>%
  left_join(pin_labels %>% select(meta_pin, meta_pin_label), by = "meta_pin") %>%
  select(-meta_pin, -primary_card) %>%
  # Convert everything to character so that we can pivot and combine feature
  # value columns
  mutate(across(everything(), as.character)) %>%
  # Pivot long so that rows are features and columns are feature values.
  # This creates two rows for each feature name, one for each PIN
  pivot_longer(
    cols = model_predictor_all_name,
    names_to = "Feature Name",
    values_to = "Value"
  ) %>%
  # Pivot back to wide so that each property has its own column representing
  # the value for each feature. This creates one row for each feature
  pivot_wider(
    names_from = meta_pin_label,
    values_from = Value
  ) %>%
  # Check which feature values match across the PINs
  mutate(
    "PINs Match" = `Pin 1` == `Pin 2`
  ) %>%
  arrange(`PINs Match`)

char_df_fmt %>%
  datatable(
    options = list(
      paging = FALSE,
      scrollX = TRUE,
      scrollY = "400px"
    )
  ) %>%
  formatStyle(
    "PINs Match",
    backgroundColor = styleEqual(c(TRUE, FALSE), c("lightgreen", "tomato"))
  )
```

### Predicted Values

```{r}
if (any(value_df$total_cards > 1, na.rm = TRUE)) {
  # Create the summary for the primary card
  summary_primary <- value_df %>%
    filter(primary_card == meta_card_num) %>%
    rename(
      "Initial estimate" = pred_card_initial_fmv,
      "Final rounded FMV" = pred_pin_final_fmv_round
    ) %>%
    pivot_longer(
      cols = c("Initial estimate", "Final rounded FMV"),
      names_to = "Value Type",
      values_to = "Value"
    ) %>%
    pivot_wider(
      names_from = meta_pin_label,
      values_from = Value
    ) %>%
    group_by(`Value Type`) %>%
    summarise(across(c(`Pin 1`, `Pin 2`), sum, na.rm = TRUE)) %>%
    mutate(
      Difference = `Pin 1` - `Pin 2`,
      Group = "Primary Card"
    )

  # Create the summary for all cards
  summary_total <- value_df %>%
    rename(
      "Initial estimate" = pred_card_initial_fmv,
      "Final rounded FMV" = pred_pin_final_fmv_round
    ) %>%
    pivot_longer(
      cols = c("Initial estimate", "Final rounded FMV"),
      names_to = "Value Type",
      values_to = "Value"
    ) %>%
    pivot_wider(
      names_from = meta_pin_label,
      values_from = Value
    ) %>%
    group_by(`Value Type`) %>%
    summarise(across(c(`Pin 1`, `Pin 2`), sum, na.rm = TRUE)) %>%
    mutate(
      Difference = `Pin 1` - `Pin 2`,
      Group = "Total"
    )

  # Bind the rows together and format the table
  final_table <- bind_rows(summary_primary, summary_total) %>%
    relocate(Group, .before = `Value Type`) %>%
    mutate(across(c("Pin 2", "Pin 1", "Difference"), scales::label_currency()))

  print(datatable(final_table, rownames = FALSE, options = list(dom = "t")))
} else {
  # Only create a single (total) summary table if no value of total_cards > 1
  final_table <- value_df %>%
    rename(
      "Initial estimate" = pred_card_initial_fmv,
      "Final rounded FMV" = pred_pin_final_fmv_round
    ) %>%
    pivot_longer(
      cols = c("Initial estimate", "Final rounded FMV"),
      names_to = "Value Type",
      values_to = "Value"
    ) %>%
    pivot_wider(
      names_from = meta_pin_label,
      values_from = Value
    ) %>%
    group_by(`Value Type`) %>%
    summarise(across(c(`Pin 1`, `Pin 2`), sum, na.rm = TRUE)) %>%
    mutate(
      Difference = `Pin 1` - `Pin 2`,
      Group = "Total"
    ) %>%
    mutate(across(c("Pin 2", "Pin 1", "Difference"), scales::label_currency()))

  print(datatable(final_table, rownames = FALSE, options = list(dom = "t")))
}
```

### Sale History

```{r}
comps <- comps %>%
  rowwise() %>%
  mutate(
    # Find the index where the comp_pin value equals the current pin
    matching_index = {
      idx <- which(c_across(starts_with("comp_pin")) == pin)
      if (length(idx) > 0) idx[1] else NA_integer_
    },
    comp_score = if (!is.na(matching_index)) {
      c_across(starts_with("comp_score_"))[matching_index]
    } else {
      NA_real_
    }
  ) %>%
  ungroup()

comps <- comps %>%
  mutate(
    row_id = row_number(),
    pin = as.character(pin)
  )

# Create a list column with the comp_pin values (converted to character)
comps <- comps %>%
  rowwise() %>%
  mutate(comp_pins = list(as.character(c_across(starts_with("comp_pin"))))) %>%
  ungroup()

# Group all rows together and, for each row, collect comp_pin values from all other rows
comps <- comps %>%
  group_by(dummy = 1) %>%
  mutate(other_comp_pins = map(row_id, ~ {
    unique(unlist(comp_pins[row_id != .x]))
  })) %>%
  ungroup() %>%
  # Use map2_lgl to compare each pin to the corresponding other_comp_pins vector
  mutate(pin_in_other_row = map2_lgl(pin, other_comp_pins, ~ .x %in% .y))

# Join with sales and select the final columns (including computed doc and comp)
sales <- sales %>%
  left_join(comps, by = c("pin" = "pin")) %>%
  mutate(
    sale_date = substr(sale_date, 1, 10),
    is_comp = ifelse(pin_in_other_row == TRUE, "✅", "")
  ) %>%
  # Select and order columns for display; note the inclusion of doc and comp
  select(pin, sale_date, sale_price, doc_no, comp_score, is_comp) %>%
  arrange(desc(sale_date))

unique_pins <- unique(sales$pin)
colors <- rainbow(length(unique_pins))

datatable_obj <- datatable(
  sales,
  options = list(order = list(list(1, "desc")))
) %>%
  formatStyle(
    "pin",
    backgroundColor = styleEqual(unique_pins, colors)
  )

datatable_obj
```

### SHAP Values

```{r}
shap_df_pivoted <- shap_df %>%
  left_join(pin_labels %>% select(meta_pin, meta_pin_label), by = c("meta_pin")) %>%
  select(-meta_pin) %>%
  pivot_longer(
    cols = all_of(model_predictor_all_name),
    names_to = "Feature Name",
    values_to = "Value"
  ) %>%
  pivot_wider(
    names_from = "meta_pin_label",
    values_from = "Value"
  ) %>%
  arrange(-`Pin 1`) %>%
  # Make `Feature Name` a factor so that ggplot doesn't order it alphabetically
  mutate(`Feature Name` = factor(`Feature Name`, levels = `Feature Name`))

# Plot the SHAPs as a dumbbell chart so we can compare the two PINs
shap_df_pivoted %>% ggplot(
  aes(y = `Feature Name`, x = `Pin 1`, xend = `Pin 2`)
) +
  geom_dumbbell(
    size_x = 1,
    size_xend = 1,
    colour_x = "red",
    colour_xend = "blue",
  ) +
  labs(
    title = "SHAP differences between the two parcels",
    x = "SHAP Value",
    y = "Feature Name"
  ) +
  theme_minimal(base_size = 5)
```

